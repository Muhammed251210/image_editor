<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro Fotoƒüraf D√ºzenleyici</title>
<style>
/* --- TEMEL STƒ∞LLER --- */
:root {
    --bg-color: #f6f6f6;
    --panel-bg: #fff;
    --text-color: #333;
    --primary: #29a1f1;
    --primary-hover: #1972ac;
    --border-color: #ccc;
}
body.dark-mode {
    --bg-color: #1a1a1a;
    --panel-bg: #2d2d2d;
    --text-color: #eee;
    --primary: #4db3ff;
    --primary-hover: #29a1f1;
    --border-color: #444;
}

body { font-family: 'Segoe UI', Arial, sans-serif; background:var(--bg-color); color:var(--text-color); text-align:center; margin:0; transition: background 0.3s, color 0.3s; }
h2 { margin-top: 15px; }

/* --- ANA KONTEYNER --- */
#container { 
    position: relative; 
    display: inline-block; 
    margin:20px 0; 
    background:var(--panel-bg); 
    box-shadow:0 0 20px rgba(0,0,0,0.1); 
    max-width:95vw; 
    /* √áer√ßeve i√ßin border-box √∂nemli */
    box-sizing: border-box;
    border: 0px solid transparent; 
    transition: border 0.2s;
    overflow: hidden; /* Dƒ±≈üarƒ± ta≈ümalarƒ± engelle */
}
#container.dragover { border: 3px dashed var(--primary); background: rgba(41, 161, 241, 0.1); }

/* Orijinal resim akƒ±≈üta durur, boyutunu korur */
#container > img#originalImg { 
    display: block; 
    width:100%; 
    height:100%; 
    object-fit:contain; 
    user-select: none; 
}

/* --- KATMANLAR VE EFEKTLER --- */
/* Filtered Container: Sadece g√∂r√ºn√ºr alanƒ± sƒ±nƒ±rlar (geni≈üliƒüi slider ile deƒüi≈üir) */
#filteredContainer { 
    position:absolute; 
    top:0; 
    left:0; 
    height:100%; 
    width: 50%; /* Ba≈ülangƒ±√ß deƒüeri */
    overflow:hidden; 
    pointer-events:none; 
    z-index: 10; 
    border-right: 1px solid rgba(255,255,255,0.5);
}

/* √ñNEMLƒ∞ D√úZELTME: Filtreli resim container daralsa bile tam boyutta kalmalƒ± */
#filteredImg { 
    position:absolute; 
    top:0; 
    left:0; 
    /* width ve height JS ile container boyutuna e≈üitlenecek */
    object-fit:contain; 
}

#vignetteOverlay, #tintOverlay { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    pointer-events: none; z-index: 12; 
}
#vignetteOverlay { transition: box-shadow 0.1s linear; }
#tintOverlay { mix-blend-mode: overlay; z-index: 13; }

/* --- COMPARE SLIDER (Kulp) --- */
#handle { 
    position:absolute; top:0; left: 50%; width:4px; height:100%; 
    background:#fff; box-shadow: 0 0 5px rgba(0,0,0,0.5); 
    cursor:ew-resize; z-index:20; transition:background .2s; 
    transform: translateX(-50%); /* Tam ortalamak i√ßin */
}
#handle::after { 
    content:''; position:absolute; top:50%; left:50%; width:30px; height:30px; 
    background:var(--primary); border-radius:50%; 
    transform:translate(-50%, -50%); 
    z-index:-1; box-shadow: 0 2px 5px rgba(0,0,0,0.3); 
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z'/%3E%3Cpath d='M14 6l1.41 1.41L10.83 12l4.58 4.59L14 18l-6-6z' transform='rotate(180 12 12)'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
}
#handle:hover { background:#eee; }

/* --- LENS MODU --- */
#lens { 
    position:absolute; border:2px solid var(--primary); border-radius:50%; 
    width:150px; height:150px; overflow:hidden; display:none; 
    z-index:21; pointer-events:none; background:rgba(255,255,255,0.05); 
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); 
}
#lensImg { position:absolute; object-fit:contain; }

/* --- UI ELEMANLARI --- */
#controls { margin:15px auto; display:flex; flex-wrap:wrap; justify-content:center; gap:10px; max-width: 800px; }
button, input[type=file], select { padding:8px 16px; border:none; border-radius:6px; cursor:pointer; font-size:0.95em; outline:none; }
button { background:var(--primary); color:#fff; transition:all .2s; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
button:hover { background:var(--primary-hover); transform: translateY(-1px); }
button:active { transform: translateY(1px); }
button:disabled { background: #aaa; cursor: not-allowed; transform: none; }

/* --- SEKME Sƒ∞STEMƒ∞ --- */
.tab-container { max-width: 800px; margin: 0 auto 20px auto; background: var(--panel-bg); border-radius: 8px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
.tabs { display: flex; border-bottom: 2px solid var(--border-color); margin-bottom: 15px; overflow-x: auto; }
.tab-btn { background: transparent; color: var(--text-color); border-radius: 0; padding: 10px 20px; box-shadow: none; opacity: 0.7; font-weight: bold; }
.tab-btn:hover { background: rgba(0,0,0,0.05); opacity: 1; transform: none; }
.tab-btn.active { border-bottom: 3px solid var(--primary); color: var(--primary); opacity: 1; }
.tab-content { display: none; animation: fadeIn 0.3s; }
.tab-content.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

/* --- KONTROL GRUPLARI --- */
.control-panel { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; align-items: center; }
.history-controls, .transform-controls, .crop-controls { display: flex; gap: 8px; justify-content: center; margin-top: 10px; }
.crop-controls { display: none; }
.crop-controls button.confirm { background: #28a745; }
.crop-controls button.cancel { background: #dc3545; }

.filter-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:15px; padding: 10px; }
.filter-item { display:flex; flex-direction:column; align-items:center; background: rgba(0,0,0,0.03); padding: 10px; border-radius: 8px; }
label { margin-bottom:5px; font-size: 0.85em; font-weight:600; color: var(--text-color); }
input[type=range] { width:100%; accent-color: var(--primary); cursor: pointer; }

/* --- PRESETS --- */
.presets { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-bottom: 10px; }
.presets button { background: #555; font-size: 0.85em; padding: 6px 12px; }
.presets button:hover { background: #333; }

/* --- METƒ∞N VE √áIKARTMA KATMANLARI --- */
#overlayLayer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 15; overflow: hidden; pointer-events: none;
}
.draggable-item {
    position: absolute; cursor: grab; user-select: none; pointer-events: auto;
    border: 1px dashed transparent; transition: border 0.2s;
}
.draggable-item:hover, .draggable-item.active { border: 1px dashed #fff; background: rgba(0,0,0,0.2); }
.draggable-item:active { cursor: grabbing; }
.draggable-text { font-weight: bold; white-space: nowrap; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); padding: 5px; }
.draggable-sticker { font-size: 40px; line-height: 1; padding: 5px; }
.remove-btn {
    position: absolute; top: -10px; right: -10px; width: 20px; height: 20px;
    background: red; color: white; border-radius: 50%; text-align: center;
    line-height: 18px; font-size: 12px; cursor: pointer; display: none;
}
.draggable-item:hover .remove-btn, .draggable-item.active .remove-btn { display: block; }

/* --- KROPLAMA ALANI --- */
#cropContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30; display: none; touch-action: none; }
#cropBox { position: absolute; box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6); border: 1px dashed #fff; cursor: move; }
.crop-handle { position: absolute; width: 12px; height: 12px; background: var(--primary); border: 2px solid #fff; border-radius: 50%; }
.handle-nw { top: -6px; left: -6px; cursor: nwse-resize; }
.handle-ne { top: -6px; right: -6px; cursor: nesw-resize; }
.handle-sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
.handle-se { bottom: -6px; right: -6px; cursor: nwse-resize; }

/* --- HEADER & DARK MODE --- */
.header-bar { display: flex; justify-content: space-between; align-items: center; padding: 0 20px; max-width: 800px; margin: 0 auto; }
.theme-toggle { background: transparent; color: var(--text-color); font-size: 1.2em; padding: 5px; box-shadow: none; }
.theme-toggle:hover { background: rgba(0,0,0,0.1); }

/* RENK SE√áƒ∞Cƒ∞LER */
input[type=color] { -webkit-appearance: none; border: none; width: 30px; height: 30px; padding: 0; overflow: hidden; border-radius: 50%; cursor: pointer; vertical-align: middle; }
input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
input[type=color]::-webkit-color-swatch { border: none; }

@media(max-width:700px){ .filter-grid { grid-template-columns: 1fr 1fr; } .tabs { font-size: 0.8em; } }
</style>
</head>
<body id="appBody">

<div class="header-bar">
    <h2>Pro Fotoƒüraf D√ºzenleyici</h2>
    <button id="themeBtn" class="theme-toggle" title="Temayƒ± Deƒüi≈ütir">üåì</button>
</div>

<div id="controls">
    <input type="file" id="upload" accept="image/*">
    <button id="save" title="Resmi indir">üíæ Kaydet</button>
    <button id="reset" title="Her ≈üeyi sƒ±fƒ±rla">üîÑ Sƒ±fƒ±rla</button>
</div>

<!-- SEKME YAPISI -->
<div class="tab-container">
    <div class="tabs">
        <button class="tab-btn active" onclick="openTab('tab-filters')">Filtreler</button>
        <button class="tab-btn" onclick="openTab('tab-adjust')">Ayarlar & Kƒ±rp</button>
        <button class="tab-btn" onclick="openTab('tab-text')">Metin & √áƒ±kartma</button>
        <button class="tab-btn" onclick="openTab('tab-frame')">√áer√ßeve & Efekt</button>
    </div>

    <!-- TAB 1: Fƒ∞LTRELER -->
    <div id="tab-filters" class="tab-content active">
        <div class="presets">
            <button data-preset="normal">Normal</button>
            <button data-preset="bw">Siyah Beyaz</button>
            <button data-preset="sepia">Sepya</button>
            <button data-preset="highcontrast">Y√ºksek Kontrast</button>
            <button data-preset="vivid">Canlƒ±</button>
            <button data-preset="vintage">Vintage</button>
            <button data-preset="kodak">Analog</button>
            <button data-preset="techno">Tekno</button>
        </div>
        <div class="filter-grid">
            <div class="filter-item"><label>Kontrast</label><input type="range" id="contrast" min="0" max="200" value="100"></div>
            <div class="filter-item"><label>Parlaklƒ±k</label><input type="range" id="brightness" min="0" max="200" value="100"></div>
            <div class="filter-item"><label>Doygunluk</label><input type="range"id="saturate" min="0" max="200" value="100"></div>
            <div class="filter-item"><label>Renk Tonu</label><input type="range" id="hue" min="0" max="360" value="0"></div>
            <div class="filter-item"><label>Sepya</label><input type="range" id="sepia" min="0" max="100" value="0"></div>
            <div class="filter-item"><label>Bulanƒ±klƒ±k</label><input type="range" id="blur" min="0" max="10" value="0" step="0.2"></div>
            <div class="filter-item"><label>Keskinlik</label><input type="range" id="sharpen" min="0" max="5" value="0" step="0.1"></div>
        </div>
    </div>

    <!-- TAB 2: AYARLAR & KIRPMA -->
    <div id="tab-adjust" class="tab-content">
        <div class="control-panel">
            <button id="modeBtn">üîç Lens Modu</button>
            <button id="cropBtn">‚úÇÔ∏è Kƒ±rpma Modu</button>
        </div>
        
        <div class="crop-controls">
            <button id="confirmCrop" class="confirm">‚úÖ Onayla</button>
            <button id="cancelCrop" class="cancel">‚ùå ƒ∞ptal</button>
        </div>

        <div class="history-controls">
            <button id="undo" disabled>‚Ü©Ô∏è Geri Al</button>
            <button id="redo" disabled>‚Ü™Ô∏è ƒ∞leri Al</button>
        </div>

        <div class="transform-controls">
            <button id="rotateLeft" title="Sola D√∂nd√ºr">‚Ü∫ 90¬∞</button>
            <button id="rotateRight" title="Saƒüa D√∂nd√ºr">‚Üª 90¬∞</button>
            <button id="flipX" title="Yatay √áevir">‚Üî Yatay</button>
            <button id="flipY" title="Dikey √áevir">‚Üï Dikey</button>
        </div>
        <div class="filter-grid" style="margin-top:10px;">
             <div class="filter-item"><label>Gamma</label><input type="range" id="gamma" min="0.1" max="3" value="1" step="0.1"></div>
             <div class="filter-item"><label>Ters √áevir</label><input type="range" id="invert" min="0" max="100" value="0"></div>
             <div class="filter-item"><label>Gri Tonlama</label><input type="range" id="grayscale" min="0" max="100" value="0"></div>
        </div>
    </div>

    <!-- TAB 3: METƒ∞N & √áIKARTMA -->
    <div id="tab-text" class="tab-content">
        <div class="control-panel">
            <div class="filter-item" style="flex-direction:row; gap:10px;">
                <input type="text" id="textInput" placeholder="Metin yazƒ±n..." style="border:1px solid #ccc; width:120px;">
                <input type="color" id="textColor" value="#ffffff" title="Yazƒ± Rengi">
                <input type="range" id="textSize" min="10" max="100" value="30" style="width:80px" title="Yazƒ± Boyutu">
                <button id="addTextBtn">‚ûï Yazƒ± Ekle</button>
            </div>
        </div>
        <hr style="border:0; border-top:1px solid var(--border-color); margin:10px 0;">
        <div class="presets">
            <button onclick="addSticker('üòé')">üòé</button>
            <button onclick="addSticker('üî•')">üî•</button>
            <button onclick="addSticker('‚ù§Ô∏è')">‚ù§Ô∏è</button>
            <button onclick="addSticker('‚≠ê')">‚≠ê</button>
            <button onclick="addSticker('üéâ')">üéâ</button>
            <button onclick="addSticker('üíØ')">üíØ</button>
            <button onclick="addSticker('üëë')">üëë</button>
            <button onclick="addSticker('üì∏')">üì∏</button>
        </div>
        <p style="font-size:0.8em; color:#888; margin-top:5px;">√ñgeleri silmek i√ßin √ºzerine tƒ±klayƒ±p kƒ±rmƒ±zƒ± √ßarpƒ±ya basƒ±n.</p>
    </div>

    <!-- TAB 4: √áER√áEVE & EFEKT -->
    <div id="tab-frame" class="tab-content">
        <div class="filter-grid">
             <div class="filter-item"><label>Vignette (K√∂≈üe Karartma)</label><input type="range" id="vignette" min="0" max="100" value="0"></div>
             <div class="filter-item">
                 <label>Renk Kaplama</label>
                 <div style="display:flex; gap:5px; align-items:center; width:100%">
                     <input type="color" id="tintColor" value="#ff9900">
                     <input type="range" id="tintOpacity" min="0" max="100" value="0">
                 </div>
             </div>
             <div class="filter-item">
                 <label>√áer√ßeve Kalƒ±nlƒ±ƒüƒ±</label>
                 <input type="range" id="borderWidth" min="0" max="50" value="0">
             </div>
             <div class="filter-item">
                 <label>√áer√ßeve Rengi</label>
                 <input type="color" id="borderColor" value="#ffffff" style="width:50px; height:30px; border-radius:4px;">
             </div>
        </div>
    </div>
</div>

<!-- RESƒ∞M ALANI -->
<div id="container" style="width:480px; height:300px;">
    <img id="originalImg" src="https://dummyimage.com/800x500/cccccc/464646.png&text=Resim+Y√ºkle">
    
    <!-- Filtreli Katman -->
    <div id="filteredContainer">
        <!-- D√úZELTME: filteredImg burada JS ile container boyutuna e≈üitlenecek -->
        <img id="filteredImg" src="https://dummyimage.com/800x500/cccccc/464646.png&text=Resim+Y√ºkle">
        <div id="vignetteOverlay"></div>
        <div id="tintOverlay"></div> 
    </div>

    <!-- S√ºr√ºkle Bƒ±rak Katmanƒ± (Metin/Sticker) -->
    <div id="overlayLayer"></div>

    <!-- Ara√ßlar -->
    <div id="handle"></div>
    <div id="lens">
        <img id="lensImg" src="https://dummyimage.com/800x500/cccccc/464646.png&text=Resim+Y√ºkle">
    </div>
    
    <!-- Kƒ±rpma Aray√ºz√º -->
    <div id="cropContainer">
        <div id="cropBox">
            <div class="crop-handle handle-nw"></div>
            <div class="crop-handle handle-ne"></div>
            <div class="crop-handle handle-sw"></div>
            <div class="crop-handle handle-se"></div>
        </div>
    </div>
</div>

<script>
// == 1. DOM Elemanlarƒ± ==
const filters = {
    contrast: document.getElementById('contrast'),
    brightness: document.getElementById('brightness'),
    saturate: document.getElementById('saturate'),
    hue: document.getElementById('hue'),
    sepia: document.getElementById('sepia'),
    blur: document.getElementById('blur'),
    vignette: document.getElementById('vignette'),
    sharpen: document.getElementById('sharpen'),
    gamma: document.getElementById('gamma'),
    invert: document.getElementById('invert'),
    grayscale: document.getElementById('grayscale')
};
const tintColorInput = document.getElementById('tintColor');
const tintOpacityInput = document.getElementById('tintOpacity');
const borderWidthInput = document.getElementById('borderWidth');
const borderColorInput = document.getElementById('borderColor');
const textInput = document.getElementById('textInput');
const textColorInput = document.getElementById('textColor');
const textSizeInput = document.getElementById('textSize');
const addTextBtn = document.getElementById('addTextBtn');
const themeBtn = document.getElementById('themeBtn');

const defaultValues = {contrast:100,brightness:100,saturate:100,hue:0,sepia:0,blur:0,vignette:0,sharpen:0,gamma:1,invert:0,grayscale:0};
const defaultTransform = { rotate: 0, scaleX: 1, scaleY: 1 };
const defaultCrop = { x: 0, y: 0, w: 100, h: 100, isApplied: false };

// DOM (Genel)
const appBody = document.getElementById('appBody');
const upload = document.getElementById('upload');
const container = document.getElementById('container');
const originalImg = document.getElementById('originalImg');
const filteredImg = document.getElementById('filteredImg');
const filteredContainer = document.getElementById('filteredContainer');
const vignetteOverlay = document.getElementById('vignetteOverlay');
const tintOverlay = document.getElementById('tintOverlay');
const overlayLayer = document.getElementById('overlayLayer');
const handle = document.getElementById('handle');
const lens = document.getElementById('lens');
const lensImg = document.getElementById('lensImg');
const modeBtn = document.getElementById('modeBtn');

// DOM (Kontroller)
const rotateLeftBtn = document.getElementById('rotateLeft');
const rotateRightBtn = document.getElementById('rotateRight');
const flipXBtn = document.getElementById('flipX');
const flipYBtn = document.getElementById('flipY');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');

// DOM (Kƒ±rpma)
const cropBtn = document.getElementById('cropBtn');
const confirmCropBtn = document.getElementById('confirmCrop');
const cancelCropBtn = document.getElementById('cancelCrop');
const cropContainer = document.getElementById('cropContainer');
const cropBox = document.getElementById('cropBox');

// Global Durum
let lensMode = false;
let isDragging = false; 
let isCropping = false;
let historyStack = [];
let historyIndex = -1;
let transformState = { ...defaultTransform };
let cropState = { ...defaultCrop };
let borderState = { width: 0, color: '#ffffff' };
let tintState = { color: '#ff9900', opacity: 0 };

let cropDragMode = null;
let cropStartX, cropStartY;
let originalCropBox = {};

// == SEKME Sƒ∞STEMƒ∞ ==
function openTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(tb => tb.classList.remove('active'));
    document.getElementById(tabName).classList.add('active');
    event.currentTarget.classList.add('active');
}

// == TEMA ==
themeBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
});

// == 2. Boyutlandƒ±rma ve G√∂r√ºnt√ºleme Mantƒ±ƒüƒ± (D√úZELTME BURADA) ==
function updateImageDimensions() {
    // Konteyner boyutlarƒ±nƒ± al
    const w = container.offsetWidth;
    const h = container.offsetHeight;
    
    // filteredImg boyutlarƒ±nƒ± KESƒ∞NLƒ∞KLE konteyner boyutlarƒ±na sabitle (piksel olarak)
    // B√∂ylece filteredContainer daralsa bile resim daralmaz, sadece g√∂r√ºn√ºr alanƒ± azalƒ±r.
    filteredImg.style.width = w + 'px';
    filteredImg.style.height = h + 'px';
    
    // Lens boyutlarƒ± da aynƒ± olmalƒ±
    if(lensImg) {
        lensImg.style.width = w + 'px';
        lensImg.style.height = h + 'px';
    }
}

// Pencere boyutu deƒüi≈üirse resim boyutlarƒ±nƒ± tekrar hesapla
window.addEventListener('resize', () => {
    updateImageDimensions();
});

// == 3. Durum Y√∂netimi ==
function getCurrentState() {
    const state = {
        filters: {},
        transform: { ...transformState },
        crop: { ...cropState },
        border: { ...borderState },
        tint: { ...tintState },
    };
    for (const key in filters) {
        state.filters[key] = filters[key].value;
    }
    return state;
}

function applyState(state) {
    if (!state) return;

    for (const key in state.filters) {
        filters[key].value = state.filters[key];
    }
    
    if(state.border) {
        borderState = state.border;
        borderWidthInput.value = borderState.width;
        borderColorInput.value = borderState.color;
    }
    if(state.tint) {
        tintState = state.tint;
        tintColorInput.value = tintState.color;
        tintOpacityInput.value = tintState.opacity;
    }

    applyFilters(); 
    transformState = { ...state.transform };
    applyTransforms();
    cropState = { ...state.crop };
    applyCropToImages(cropState);
}

function saveState() {
    if (historyIndex < historyStack.length - 1) {
        historyStack = historyStack.slice(0, historyIndex + 1);
    }
    const newState = getCurrentState();
    if (historyIndex > -1 && JSON.stringify(newState) === JSON.stringify(historyStack[historyIndex])) {
        return; 
    }
    historyStack.push(newState);
    historyIndex++;
    updateHistoryButtons();
}

function updateHistoryButtons() {
    undoBtn.disabled = (historyIndex <= 0);
    redoBtn.disabled = (historyIndex >= historyStack.length - 1);
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        applyState(historyStack[historyIndex]);
        updateHistoryButtons();
    }
}
function redo() {
    if (historyIndex < historyStack.length - 1) {
        historyIndex++;
        applyState(historyStack[historyIndex]);
        updateHistoryButtons();
    }
}

// == 4. Ana Fonksiyonlar ==
function applyFilters() {
    let filterStr =
        `contrast(${filters.contrast.value}%) brightness(${filters.brightness.value}%) ` +
        `saturate(${filters.saturate.value}%) hue-rotate(${filters.hue.value}deg) ` +
        `sepia(${filters.sepia.value}%) blur(${filters.blur.value}px) ` +
        `invert(${filters.invert.value}%) grayscale(${filters.grayscale.value}%)`;
    
    filteredImg.style.filter = filterStr;
    lensImg.style.filter = filterStr;
    
    const vignetteValue = filters.vignette.value;
    const spread = (vignetteValue / 100) * 150;
    const opacity = vignetteValue / 100;
    if (vignetteOverlay) {
        vignetteOverlay.style.boxShadow = `inset 0 0 ${spread}px ${spread / 2}px rgba(0,0,0,${opacity})`;
    }

    if(tintOverlay) {
        tintOverlay.style.backgroundColor = tintState.color;
        tintOverlay.style.opacity = tintState.opacity / 100;
    }

    container.style.border = `${borderState.width}px solid ${borderState.color}`;
}

function applyTransforms() {
    const transformStr = `
        rotate(${transformState.rotate}deg) 
        scaleX(${transformState.scaleX}) 
        scaleY(${transformState.scaleY})
    `;
    originalImg.style.transform = transformStr;
    filteredImg.style.transform = transformStr;
    lensImg.style.transform = transformStr;
    overlayLayer.style.transform = transformStr;
    updateLensSize(); // Lensi ta≈üƒ±
}

function applyCropToImages(cropData) {
    if (cropData.isApplied) {
        const top = cropData.y;
        const left = cropData.x;
        const bottom = 100 - (cropData.y + cropData.h);
        const right = 100 - (cropData.x + cropData.w);
        const clipPathValue = `inset(${top}% ${right}% ${bottom}% ${left}%)`;

        // FilteredContainer'a clipPath uygulamƒ±yoruz, √ß√ºnk√º o slider i≈ülevi g√∂r√ºyor
        // FilteredImg'e uyguluyoruz
        filteredImg.style.clipPath = clipPathValue;
        originalImg.style.clipPath = clipPathValue;
        lensImg.style.clipPath = clipPathValue;
        overlayLayer.style.clipPath = clipPathValue;
    } else {
        filteredImg.style.clipPath = 'none';
        originalImg.style.clipPath = 'none';
        lensImg.style.clipPath = 'none';
        overlayLayer.style.clipPath = 'none';
    }
}

function handleFile(file) {
    if (!file || !file.type.startsWith('image/')) return;
    const url = URL.createObjectURL(file);
    originalImg.src = url;
    filteredImg.src = url;
    lensImg.src = url;

    originalImg.onload = () => {
        let w = originalImg.naturalWidth;
        let h = originalImg.naturalHeight;
        const maxW = window.innerWidth * 0.9;
        const maxH = window.innerHeight * 0.6;
        
        container.style.width = Math.min(w, maxW) + 'px';
        container.style.height = (Math.min(w, maxW) * (h/w)) + 'px';

        // Boyutlarƒ± hemen g√ºncelle
        setTimeout(() => {
             updateImageDimensions();
        }, 50);
        
        resetAll(); 
        overlayLayer.innerHTML = '';
        
        historyStack = [];
        historyIndex = -1;
        saveState(); 
        updateHistoryButtons();
    };
}

function resetAll() {
    Object.keys(filters).forEach(k => filters[k].value = defaultValues[k]);
    transformState = { ...defaultTransform };
    cropState = { ...defaultCrop };
    borderState = { width: 0, color: '#ffffff' };
    tintState = { color: '#ff9900', opacity: 0 };
    
    borderWidthInput.value = 0;
    tintOpacityInput.value = 0;
    
    applyFilters();
    applyTransforms();
    applyCropToImages(cropState);
    
    lensMode = false;
    lens.style.display = 'none';
    handle.style.display = 'block';
    filteredContainer.style.opacity = '1';
    filteredContainer.style.width = '50%';
    handle.style.left = '50%';
    modeBtn.textContent = 'üîç Lens Modu';
    modeBtn.classList.remove('active');
    
    updateImageDimensions(); // Reset sonrasƒ± boyutlarƒ± garantiye al
}

// Slider hareketi
function moveHandle(clientX){
    const rect = container.getBoundingClientRect();
    const offsetX = Math.min(Math.max(clientX - rect.left, 0), rect.width);
    handle.style.left = `${offsetX}px`;
    filteredContainer.style.width = `${offsetX}px`;
}

function updateLensSize(){
    if(!lensImg) return;
    // Lens resmi container boyutuyla aynƒ± olmalƒ±
    lensImg.style.width = container.offsetWidth + 'px';
    lensImg.style.height = container.offsetHeight + 'px';
}

function moveLens(clientX,clientY){
    const rect = container.getBoundingClientRect();
    const lensSize = lens.offsetWidth;
    
    const x = clientX - rect.left - (lensSize / 2);
    const y = clientY - rect.top - (lensSize / 2);
    
    lens.style.left = `${x}px`;
    lens.style.top = `${y}px`;

    lensImg.style.left = `${-x}px`;
    lensImg.style.top = `${-y}px`;
}

// == 5. Metin ve Sticker ==
function makeDraggable(el) {
    let isDraggingEl = false;
    let startX, startY, initialLeft, initialTop;

    el.addEventListener('mousedown', startDrag);
    el.addEventListener('touchstart', startDrag, {passive: false});

    function startDrag(e) {
        if(e.target.classList.contains('remove-btn')) return;
        isDraggingEl = true;
        
        document.querySelectorAll('.draggable-item').forEach(i => i.classList.remove('active'));
        el.classList.add('active');

        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

        startX = clientX;
        startY = clientY;
        initialLeft = el.offsetLeft;
        initialTop = el.offsetTop;

        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', drag, {passive: false});
        document.addEventListener('touchend', stopDrag);
    }

    function drag(e) {
        if (!isDraggingEl) return;
        e.preventDefault();
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        const dx = clientX - startX;
        const dy = clientY - startY;
        el.style.left = `${initialLeft + dx}px`;
        el.style.top = `${initialTop + dy}px`;
    }

    function stopDrag() {
        isDraggingEl = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('touchend', stopDrag);
    }
}

addTextBtn.addEventListener('click', () => {
    const text = textInput.value;
    if(!text) return;
    const div = document.createElement('div');
    div.className = 'draggable-item';
    div.style.left = '30%'; div.style.top = '30%';
    
    const span = document.createElement('div');
    span.className = 'draggable-text';
    span.textContent = text;
    span.style.color = textColorInput.value;
    span.style.fontSize = textSizeInput.value + 'px';
    
    const removeBtn = document.createElement('div');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = 'X';
    removeBtn.onclick = () => div.remove();
    
    div.appendChild(span); div.appendChild(removeBtn);
    overlayLayer.appendChild(div);
    makeDraggable(div);
    textInput.value = '';
});

window.addSticker = function(emoji) {
    const div = document.createElement('div');
    div.className = 'draggable-item';
    div.style.left = '40%'; div.style.top = '40%';
    
    const span = document.createElement('div');
    span.className = 'draggable-sticker';
    span.textContent = emoji;
    
    const removeBtn = document.createElement('div');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = 'X';
    removeBtn.onclick = () => div.remove();
    
    div.appendChild(span); div.appendChild(removeBtn);
    overlayLayer.appendChild(div);
    makeDraggable(div);
}

// == 6. Kƒ±rpma Mantƒ±ƒüƒ± ==
function startCropping() {
    isCropping = true;
    // √ñnce lens modunu kapat
    if(lensMode) modeBtn.click();
    
    appBody.classList.add('cropping');
    cropContainer.style.display = 'block';
    
    const containerRect = container.getBoundingClientRect();
    const w = containerRect.width;
    const h = containerRect.height;
    let cx = cropState.isApplied ? cropState.x : 0;
    let cy = cropState.isApplied ? cropState.y : 0;
    let cw = cropState.isApplied ? cropState.w : 100;
    let ch = cropState.isApplied ? cropState.h : 100;

    cropBox.style.left = (cx / 100 * w) + 'px';
    cropBox.style.top = (cy / 100 * h) + 'px';
    cropBox.style.width = (cw / 100 * w) + 'px';
    cropBox.style.height = (ch / 100 * h) + 'px';
}

function cancelCropping() {
    isCropping = false;
    appBody.classList.remove('cropping');
    cropContainer.style.display = 'none';
}

function confirmCropping() {
    isCropping = false;
    appBody.classList.remove('cropping');
    cropContainer.style.display = 'none';
    
    const containerRect = container.getBoundingClientRect();
    const boxRect = cropBox.getBoundingClientRect();
    const relX = boxRect.left - containerRect.left;
    const relY = boxRect.top - containerRect.top;
    
    let newX = (relX / containerRect.width) * 100;
    let newY = (relY / containerRect.height) * 100;
    let newW = (boxRect.width / containerRect.width) * 100;
    let newH = (boxRect.height / containerRect.height) * 100;

    newX = Math.max(0, newX); newY = Math.max(0, newY);
    
    cropState = { x: newX, y: newY, w: newW, h: newH, isApplied: true };
    applyCropToImages(cropState);
    saveState();
}

cropContainer.addEventListener('mousedown', startCropDrag);
cropContainer.addEventListener('touchstart', startCropDrag, { passive: false });

function startCropDrag(e) {
    if (!isCropping) return;
    e.preventDefault(); 
    const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
    const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
    cropStartX = clientX;
    cropStartY = clientY;
    
    const target = e.target;
    if (target.classList.contains('crop-handle')) {
        cropDragMode = target.className.split(' ')[1].replace('handle-', '');
    } else if (target === cropBox) {
        cropDragMode = 'move';
    } else {
        return;
    }

    originalCropBox = {
        left: cropBox.offsetLeft,
        top: cropBox.offsetTop,
        width: cropBox.offsetWidth,
        height: cropBox.offsetHeight
    };
    
    document.addEventListener('mousemove', handleCropDrag);
    document.addEventListener('mouseup', endCropDrag);
    document.addEventListener('touchmove', handleCropDrag, { passive: false });
    document.addEventListener('touchend', endCropDrag);
}

function handleCropDrag(e) {
    if (!cropDragMode) return;
    e.preventDefault();
    const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
    const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
    const dx = clientX - cropStartX;
    const dy = clientY - cropStartY;
    
    let { left, top, width, height } = originalCropBox;
    const maxW = container.offsetWidth;
    const maxH = container.offsetHeight;

    if (cropDragMode === 'move') {
        left += dx; top += dy;
    } else {
        if (cropDragMode.includes('n')) { height -= dy; top += dy; }
        if (cropDragMode.includes('s')) { height += dy; }
        if (cropDragMode.includes('w')) { width -= dx; left += dx; }
        if (cropDragMode.includes('e')) { width += dx; }
    }
    
    if(width < 20) width = 20; if(height < 20) height = 20;
    if(left < 0) left = 0; if(top < 0) top = 0;
    if(left + width > maxW) width = maxW - left;
    if(top + height > maxH) height = maxH - top;

    cropBox.style.left = left + 'px';
    cropBox.style.top = top + 'px';
    cropBox.style.width = width + 'px';
    cropBox.style.height = height + 'px';
}

function endCropDrag() {
    cropDragMode = null;
    document.removeEventListener('mousemove', handleCropDrag);
    document.removeEventListener('mouseup', endCropDrag);
    document.removeEventListener('touchmove', handleCropDrag);
    document.removeEventListener('touchend', endCropDrag);
}

// == 7. Olay Dinleyicileri ==
borderWidthInput.addEventListener('input', (e) => { borderState.width = e.target.value; applyFilters(); });
borderColorInput.addEventListener('input', (e) => { borderState.color = e.target.value; applyFilters(); });
tintColorInput.addEventListener('input', (e) => { tintState.color = e.target.value; applyFilters(); });
tintOpacityInput.addEventListener('input', (e) => { tintState.opacity = e.target.value; applyFilters(); });

undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

Object.values(filters).forEach(f => {
    f.addEventListener('input', applyFilters);
    f.addEventListener('change', saveState);
});

upload.addEventListener('change', e => { handleFile(e.target.files[0]); });
container.addEventListener('dragover', e => { e.preventDefault(); container.classList.add('dragover'); });
container.addEventListener('dragleave', e => { e.preventDefault(); container.classList.remove('dragover'); });
container.addEventListener('drop', e => {
    e.preventDefault();
    container.classList.remove('dragover');
    handleFile(e.dataTransfer.files[0]);
});

document.getElementById('reset').addEventListener('click', () => { resetAll(); saveState(); });

modeBtn.addEventListener('click', () => {
    lensMode = !lensMode;
    if (lensMode) {
        lens.style.display = 'block';
        handle.style.display = 'none';
        filteredContainer.style.opacity = '0';
        modeBtn.textContent = 'üìè √áubuk Modu';
        modeBtn.classList.add('active');
        updateLensSize();
    } else {
        lens.style.display = 'none';
        handle.style.display = 'block';
        filteredContainer.style.opacity = '1';
        filteredContainer.style.width = '50%';
        handle.style.left = '50%';
        modeBtn.textContent = 'üîç Lens Modu';
        modeBtn.classList.remove('active');
    }
});

container.addEventListener('mousemove', e => { if (lensMode) moveLens(e.clientX, e.clientY); });
container.addEventListener('touchmove', e => { if (lensMode && e.touches.length > 0) { e.preventDefault(); moveLens(e.touches[0].clientX, e.touches[0].clientY); }});

document.querySelectorAll('.presets button[data-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
        Object.keys(filters).forEach(k => filters[k].value = defaultValues[k]);
        switch (btn.dataset.preset) {
            case 'bw': filters.grayscale.value = 100; filters.sepia.value = 0; break;
            case 'sepia': filters.sepia.value = 100; filters.grayscale.value = 0; break;
            case 'highcontrast': filters.contrast.value = 150; break;
            case 'vivid': filters.saturate.value = 150; filters.brightness.value = 110; break;
            case 'vintage': filters.sepia.value = 40; filters.contrast.value=90; filters.brightness.value=110; filters.vignette.value=40; break;
            case 'kodak': filters.saturate.value=130; filters.contrast.value=120; filters.hue.value=10; break;
            case 'techno': filters.invert.value=10; filters.saturate.value=150; filters.hue.value=180; break;
        }
        applyFilters();
        saveState();
    });
});

rotateRightBtn.addEventListener('click', () => { transformState.rotate = (transformState.rotate + 90) % 360; applyTransforms(); saveState(); });
rotateLeftBtn.addEventListener('click', () => { transformState.rotate = (transformState.rotate - 90 + 360) % 360; applyTransforms(); saveState(); });
flipXBtn.addEventListener('click', () => { transformState.scaleX *= -1; applyTransforms(); saveState(); });
flipYBtn.addEventListener('click', () => { transformState.scaleY *= -1; applyTransforms(); saveState(); });

cropBtn.addEventListener('click', startCropping);
cancelCropBtn.addEventListener('click', cancelCropping);
confirmCropBtn.addEventListener('click', confirmCropping);

function handleDragMove(e) {
    if (isDragging) {
        e.preventDefault(); 
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        moveHandle(clientX);
    }
}
function handleDragEnd() {
    isDragging = false;
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    document.removeEventListener('touchmove', handleDragMove);
    document.removeEventListener('touchend', handleDragEnd);
}
function handleDragStart(e) {
    if (lensMode || isCropping) return;
    isDragging = true;
    e.preventDefault(); 
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
}
handle.addEventListener('mousedown', handleDragStart);
handle.addEventListener('touchstart', handleDragStart, { passive: false });

// == 8. Kaydetme ==
document.getElementById('save').addEventListener('click', () => {
    if (!originalImg.src || originalImg.src.includes('dummyimage')) return;

    const currentState = getCurrentState();
    const naturalW = originalImg.naturalWidth;
    const naturalH = originalImg.naturalHeight;
    const crop = currentState.crop;
    const sx = crop.isApplied ? (naturalW * (crop.x / 100)) : 0;
    const sy = crop.isApplied ? (naturalH * (crop.y / 100)) : 0;
    const sWidth = crop.isApplied ? (naturalW * (crop.w / 100)) : naturalW;
    const sHeight = crop.isApplied ? (naturalH * (crop.h / 100)) : naturalH;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const isSwapped = (currentState.transform.rotate % 180 !== 0);
    canvas.width = isSwapped ? sHeight : sWidth;
    canvas.height = isSwapped ? sWidth : sHeight;

    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(currentState.transform.rotate * Math.PI / 180);
    ctx.scale(currentState.transform.scaleX, currentState.transform.scaleY);

    const f = currentState.filters;
    ctx.filter = `contrast(${f.contrast}%) brightness(${f.brightness}%) saturate(${f.saturate}%) hue-rotate(${f.hue}deg) sepia(${f.sepia}%) blur(${f.blur}px) invert(${f.invert}%) grayscale(${f.grayscale}%)`;

    ctx.drawImage(originalImg, sx, sy, sWidth, sHeight, -sWidth / 2, -sHeight / 2, sWidth, sHeight);
    
    ctx.filter = 'none';
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    if (f.gamma != 1 || f.sharpen > 0) {
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        const gamma = f.gamma != 1 ? (1 / f.gamma) : 1;
        const sharp = f.sharpen;
        for (let i = 0; i < data.length; i += 4) {
            if(gamma !== 1) {
                data[i] = 255 * Math.pow(data[i] / 255, gamma);
                data[i + 1] = 255 * Math.pow(data[i + 1] / 255, gamma);
                data[i + 2] = 255 * Math.pow(data[i + 2] / 255, gamma);
            }
            if(sharp > 0 && i > 4) {
                 data[i] += sharp * (data[i] - data[i-4]);
                 data[i+1] += sharp * (data[i+1] - data[i-3]);
                 data[i+2] += sharp * (data[i+2] - data[i-2]);
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    if(tintState.opacity > 0) {
        ctx.globalCompositeOperation = 'overlay';
        ctx.fillStyle = tintState.color;
        ctx.globalAlpha = tintState.opacity / 100;
        ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
    }

    if (f.vignette > 0) {
        const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 1.2);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, `rgba(0,0,0,${f.vignette / 100})`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    const containerRect = container.getBoundingClientRect();
    const scaleFactorX = canvas.width / containerRect.width;
    const scaleFactorY = canvas.height / containerRect.height;
    
    const overlayItems = overlayLayer.querySelectorAll('.draggable-item');
    overlayItems.forEach(item => {
        const rect = item.getBoundingClientRect();
        const relativeX = rect.left - containerRect.left;
        const relativeY = rect.top - containerRect.top;
        const canvasX = relativeX * scaleFactorX;
        const canvasY = relativeY * scaleFactorY;
        const textDiv = item.querySelector('.draggable-text');
        const stickerDiv = item.querySelector('.draggable-sticker');
        
        if(textDiv) {
            const fontSize = parseInt(textDiv.style.fontSize) * scaleFactorX; 
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = textDiv.style.color;
            ctx.textBaseline = 'top';
            ctx.fillText(textDiv.textContent, canvasX + (5 * scaleFactorX), canvasY + (5 * scaleFactorY));
        } else if(stickerDiv) {
            const fontSize = 40 * scaleFactorX; 
            ctx.font = `${fontSize}px Arial`;
            ctx.textBaseline = 'top';
            ctx.fillText(stickerDiv.textContent, canvasX, canvasY);
        }
    });

    if(borderState.width > 0) {
        const bw = borderState.width * scaleFactorX; 
        ctx.strokeStyle = borderState.color;
        ctx.lineWidth = bw;
        ctx.strokeRect(bw/2, bw/2, canvas.width - bw, canvas.height - bw);
    }

    const dataURL = canvas.toDataURL("image/jpeg", 0.9);
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'pro_duzenlenmis_resim.jpg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
});

resetAll();
</script>
</body>
</html>


